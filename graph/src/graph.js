// Generated by CoffeeScript 1.8.0
(function(d3) {
  d3.graph = function(graph) {
    var links, nodes;
    if (graph == null) {
      graph = {};
    }
    nodes = [];
    links = [];
    graph.description = function() {
      return 'd3.graph with ' + nodes.length + ' nodes and ' + links.length + ' links';
    };
    graph.nodes = function(_nodes) {
      if (_nodes == null) {
        return nodes;
      }
      nodes = _nodes;
      return this;
    };
    graph.links = function(_links) {
      if (_links == null) {
        return links;
      }
      links = _links;
      return this;
    };
    graph.matrix = function(_matrix) {};
    return graph;
  };
  d3.graph.matrix = function(matrix) {
    var matrixObj;
    if (matrix == null) {
      matrix = [];
    }
    matrixObj = function(i, j) {
      return matrix[i][j];
    };
    matrixObj.description = function() {
      return matrix.length + ' adjacency matrix';
    };
    matrixObj.data = matrixObj.matrix = function(_matrix) {
      if (_matrix == null) {
        return matrix;
      }
      matrix = _matrix;
      return this;
    };
    matrixObj.set = matrixObj.addEdge = function(i, j, value) {
      if (value === 0) {
        console.warn('addEdge: argument "value" is 0. It could lead to unpredictable behavior');
      }
      matrix[i][j] = value != null ? value : 1;
      return this;
    };
    matrixObj.remove = matrixObj.removeEdge = function(i, j) {
      matrix[i][j] = 0;
      return this;
    };
    matrixObj.has = matrixObj.hasEdge = function(i, j) {
      return !!matrix[i][j];
    };
    matrixObj.outE = matrixObj.outEdges = function(i) {
      var edge, _i, _len, _ref, _results;
      _ref = matrix[i];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        edge = _ref[_i];
        if (edge) {
          _results.push(edge);
        }
      }
      return _results;
    };
    matrixObj.inE = matrixObj.inEdges = function(j) {
      var row, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = matrix.length; _i < _len; _i++) {
        row = matrix[_i];
        if (row[j]) {
          _results.push(row[j]);
        }
      }
      return _results;
    };
    matrixObj.connectedEdges = matrixObj.connectedE = function(i) {
      return matrixObj.inEdges(i).concat(matrixObj.outEdges(i));
    };
    matrixObj.inOutE = matrixObj.inOutEdges = matrixObj.connectedEdges;
    matrixObj.outInE = matrixObj.outInEdges = matrixObj.connectedEdges;
    return matrixObj;
  };
  d3.graph.listToMatrix = function(links) {
    var i, link, matrix, max, _i, _len;
    max = d3.max(links, function(d) {
      return d3.max([d.source, d.target]);
    });
    matrix = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 1; 1 <= max ? _i <= max : _i >= max; i = 1 <= max ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (i = _j = 1; 1 <= max ? _j <= max : _j >= max; i = 1 <= max ? ++_j : --_j) {
            _results1.push(0);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    for (_i = 0, _len = links.length; _i < _len; _i++) {
      link = links[_i];
      matrix[links.source][link.target] = 1;
    }
    return matrix;
  };
  return d3.graph.matrixToList = function(matrix) {
    var element, i, j, links, row, _i, _j, _len, _len1;
    links = [];
    for (i = _i = 0, _len = matrix.length; _i < _len; i = ++_i) {
      row = matrix[i];
      for (j = _j = 0, _len1 = row.length; _j < _len1; j = ++_j) {
        element = row[j];
        links.push({
          source: i,
          target: j,
          value: matrix[i][j]
        });
      }
    }
    return links;
  };
})(d3);

//# sourceMappingURL=graph.js.map
